import { AccessibilityCheckerReport } from "../types"
import { calculateElementsWithNoViolationsPercentage } from "./calculateElementsWithNoViolationsPercentage"
import { createSinglePageReport } from "./createSinglePageReport"
import { LevelIssueCount, MultiPageReport } from "./types"

/**
 * Aggregates multiple single page reports into a joined multi page report.
 *
 * @param url The entry point from which the reports were generated. Usually this should be the home page of the domain.
 * @param logoUrl The URL of the logo that should be displayed in the report.
 * @param accessibilityCheckerReports The reports generated by the accessibility checker tool which should be aggregated.
 * @returns A multi page report that contains all aggregated single page reports.
 */
export const createMultiPageReport = (
  url: URL,
  logoUrl: URL,
  screenshotPath: string | null,
  accessibilityCheckerReports: AccessibilityCheckerReport[],
) => {
  const multiPageReport: MultiPageReport = {
    url: url.origin,
    logoUrl: logoUrl.href,
    screenshotPath,
    pageCount: 0,
    pageReports: [],
    categoryIssueCounts: [],
    summary: {
      totalIssueCount: 0,
      levelIssueCounts: [],
      elementCount: 0,
      elementWithViolationCount: 0,
      elementsWithNoViolationsPercentage: 0,
    },
  }

  for (const accessibilityCheckerReport of accessibilityCheckerReports) {
    const singlePageReport = createSinglePageReport(accessibilityCheckerReport)

    // The aggregation of the category issue counts is a bit more complex since
    // they're stored in an array, we have to find them in the multiPageReport
    // and aggregate them one by one.
    for (const singlePageCategoryIssueCounts of singlePageReport.categoryIssueCounts) {
      const multiPageCategoryIssueCount = multiPageReport.categoryIssueCounts.find(
        (category) => category.name === singlePageCategoryIssueCounts.name,
      )

      // If we can't find the category in the multi page report, we copy the current one
      if (!multiPageCategoryIssueCount) {
        multiPageReport.categoryIssueCounts.push({
          name: singlePageCategoryIssueCounts.name,
          totalIssueCount: singlePageCategoryIssueCounts.totalIssueCount,
          levelIssueCounts: singlePageCategoryIssueCounts.levelIssueCounts.map((level) => ({
            ...level,
          })),
        })
        continue
      }

      multiPageCategoryIssueCount.totalIssueCount += singlePageCategoryIssueCounts.totalIssueCount
      aggregateLevelIssueCounts(
        multiPageCategoryIssueCount.levelIssueCounts,
        singlePageCategoryIssueCounts.levelIssueCounts,
      )
    }

    // Here we aggregate the simpler values of the multi page report
    multiPageReport.pageCount++
    multiPageReport.pageReports.push(singlePageReport)
    multiPageReport.summary.totalIssueCount += singlePageReport.summary.totalIssueCount

    aggregateLevelIssueCounts(
      multiPageReport.summary.levelIssueCounts,
      singlePageReport.summary.levelIssueCounts,
    )

    multiPageReport.summary.elementCount += singlePageReport.summary.elementCount
    multiPageReport.summary.elementWithViolationCount +=
      singlePageReport.summary.elementWithViolationCount
  }

  multiPageReport.summary.elementsWithNoViolationsPercentage =
    calculateElementsWithNoViolationsPercentage(
      multiPageReport.summary.elementCount,
      multiPageReport.summary.elementWithViolationCount,
    )

  return multiPageReport
}

function aggregateLevelIssueCounts(
  aggregatedLevelIssueCounts: LevelIssueCount[],
  levelIssueCountsToAggregate: LevelIssueCount[],
) {
  // The aggregation of the level issue counts is a bit more complex since
  // they're stored in an array, we have to find them in the aggregatedLevelIssueCounts
  // and aggregate them one by one.
  for (const levelIssueCountToAggregate of levelIssueCountsToAggregate) {
    const aggregatedLevelIssueCount = aggregatedLevelIssueCounts.find(
      (level) => level.name === levelIssueCountToAggregate.name,
    )

    // If we can't find the category in the multi page report, we copy the current one
    if (!aggregatedLevelIssueCount) {
      aggregatedLevelIssueCounts.push({ ...levelIssueCountToAggregate })
      continue
    }

    aggregatedLevelIssueCount.issueCount += levelIssueCountToAggregate.issueCount
  }
}
